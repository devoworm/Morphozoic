// For conditions of distribution and use, see copyright notice in Morphozoic.java

package morphozoic.applications;

import java.awt.Dimension;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Random;
import morphozoic.Parameters;

// Optimize ImageRepair application.
public class ImageRepairOptimizer
{
   // Options.
   public static final String OPTIONS =
      "\n\t[-organismDimensions <width> <height> (# cells)]"
      + "\n\t[-numCellTypes <number of cell types>]"
      + "\n\t[-randomSeed <random seed>]"
      + "\n\t[-populationSize <number of members>]"
      + "\n\t[-fitPopulationSize <number of fit members retained per generation>]"
      + "\n\t[-crossoverProbability <probability of member generated by crossover>]"
      + "\n\t[-numGenerations <number of generations>]"
      + "\n\t[-numUpdateSteps <number of repair update steps>]"
      + "\n\t[-minNeighborhoodDimension <minimum neighborhood dimension>]"
      + "\n\t[-maxNeighborhoodDimension <maximum neighborhood dimension>]"
      + "\n\t[-minNumNeighborhoods <minimum number of neighborhoods>]"
      + "\n\t[-maxNumNeighborhoods <maximum number of neighborhoods>]"
      + "\n\t[-minMetamorphDimension <minimum metamorph dimension>]"
      + "\n\t[-maxMetamorphDimension <maximum metamorph dimension>]"
      + "\n\t[-minMaxCellMetamorphs <minimum maximum cell metamorphs>]"
      + "\n\t[-maxMaxCellMetamorphs <maximum maximum cell metamorphs>]"
      + "\n\t[-minMetamorphRandomBias <minimum metamorph random bias>]"
      + "\n\t[-maxMetamorphRandomBias <maximum metamorph random bias>]"
      + "\n\t[-deltaMetamorphRandomBias <delta metamorph random bias>]"
      + "\n\t[-inhibitCompetingMorphogens <\"true\", \"false\", or \"random\">]"
      + "\n\t[-imageFilename <image file name>]"
      + "\n\t[-numHoles <number of holes made in image>]"
      + "\n\t[-maxHoleSize <maximum hold size in cells>]";

   // Optimization parameters:

   // Population size.
   public static int POPULATION_SIZE = 10;

   // Number of fit members retained per generation.
   public static int FIT_POPULATION_SIZE = 5;

   // Crossover probability.
   public static float CROSSOVER_PROBABILITY = 0.5f;

   // Number of generations.
   public static int NUM_GENERATIONS = 2;

   // Number of update steps.
   public static int NUM_UPDATE_STEPS = 20;

   // Neighborhood dimension range: odd number.
   public static int MIN_NEIGHBORHOOD_DIMENSION = 3;
   public static int MAX_NEIGHBORHOOD_DIMENSION = 3;

   // Number of neighborhoods range.
   public static int MIN_NUM_NEIGHBORHOODS = 1;
   public static int MAX_NUM_NEIGHBORHOODS = 3;

   // Metamorph dimension range: odd number.
   public static int MIN_METAMORPH_DIMENSION = 1;
   public static int MAX_METAMORPH_DIMENSION = 1;

   // Maximum number of metamorphs matching cell morphogen range.
   public static int MIN_MAX_CELL_METAMORPHS = 1;
   public static int MAX_MAX_CELL_METAMORPHS = 1;

   // Metamorph selection randomness bias range.
   public static float MIN_METAMORPH_RANDOM_BIAS   = 0.0f;
   public static float MAX_METAMORPH_RANDOM_BIAS   = 0.0f;
   public static float DELTA_METAMORPH_RANDOM_BIAS = 0.001f;

   // Inhibit competing morphogen range.
   public static enum INHIBIT_COMPETING_MORPHOGENS_VALUES
   {
      TRUE,
      FALSE,
      RANDOM
   }
   public static INHIBIT_COMPETING_MORPHOGENS_VALUES INHIBIT_COMPETING_MORPHOGENS = INHIBIT_COMPETING_MORPHOGENS_VALUES.RANDOM;

   // ImageRepair population member.
   class ImageRepairMember
   {
      // Fitness.
      float fitness;

      // Parameters:

      // Neighborhood dimension: odd number.
      int NEIGHBORHOOD_DIMENSION;

      // Number of neighborhoods.
      int NUM_NEIGHBORHOODS;

      // Nested neighborhood importance weights.
      // Weight array of size NUM_NEIGHBORHOODS summing to 1.
      float[] NESTED_NEIGHBORHOOD_IMPORTANCE_WEIGHTS;

      // Metamorph dimension: odd number.
      int METAMORPH_DIMENSION;

      // Maximum number of metamorphs matching cell morphogen.
      // For weighted metamorph selection.
      int MAX_CELL_METAMORPHS;

      // Metamorph selection randomness bias.
      // 0 = least random.
      float METAMORPH_RANDOM_BIAS;

      // Inhibit competing morphogens?
      boolean INHIBIT_COMPETING_MORPHOGENS;

      // Evaluate fitness.
      void evaluate(ImageRepair fitnessTarget) throws Exception
      {
         // Set parameters.
         setParameters();

         // Update.
         ImageRepair imageRepair = new ImageRepair(new String[0], 0);
         for (int i = 0; i < NUM_UPDATE_STEPS; i++)
         {
            imageRepair.update();
         }

         // Evaluate.
         fitness = 0.0f;
         float max = (float)(Parameters.ORGANISM_DIMENSIONS.width * Parameters.ORGANISM_DIMENSIONS.height);
         for (int x = 0; x < Parameters.ORGANISM_DIMENSIONS.width; x++)
         {
            for (int y = 0; y < Parameters.ORGANISM_DIMENSIONS.height; y++)
            {
               if (imageRepair.cells[x][y].type != fitnessTarget.cells[x][y].type)
               {
                  fitness += 1.0f;
               }
            }
         }
         fitness     = (max - fitness) / max;
         imageRepair = null;
      }


      // Set parameters.
      void setParameters()
      {
         Parameters.NEIGHBORHOOD_DIMENSION = NEIGHBORHOOD_DIMENSION;
         Parameters.NUM_NEIGHBORHOODS      = NUM_NEIGHBORHOODS;
         Parameters.NESTED_NEIGHBORHOOD_IMPORTANCE_WEIGHTS = NESTED_NEIGHBORHOOD_IMPORTANCE_WEIGHTS;
         Parameters.METAMORPH_DIMENSION          = METAMORPH_DIMENSION;
         Parameters.MAX_CELL_METAMORPHS          = MAX_CELL_METAMORPHS;
         Parameters.METAMORPH_RANDOM_BIAS        = METAMORPH_RANDOM_BIAS;
         Parameters.INHIBIT_COMPETING_MORPHOGENS = INHIBIT_COMPETING_MORPHOGENS;
      }
   }

   // ImageRepair population.
   ArrayList<ImageRepairMember> population;

   // Random numbers.
   Random randomizer;

   // Fitness target.
   ImageRepair fitnessTarget;

   // Constructor.
   public ImageRepairOptimizer() throws IllegalArgumentException, IOException, Exception
   {
      // Print settings.
      System.out.println("Settings:");
      System.out.println("ORGANISM_DIMENSIONS=" + Parameters.ORGANISM_DIMENSIONS.width + "," + Parameters.ORGANISM_DIMENSIONS.height);
      System.out.println("NUM_CELL_TYPES=" + Parameters.NUM_CELL_TYPES);
      System.out.println("RANDOM_SEED=" + Parameters.RANDOM_SEED);
      System.out.println("POPULATION_SIZE=" + POPULATION_SIZE);
      System.out.println("FIT_POPULATION_SIZE=" + FIT_POPULATION_SIZE);
      System.out.println("CROSSOVER_PROBABILITY=" + CROSSOVER_PROBABILITY);
      System.out.println("NUM_GENERATIONS=" + NUM_GENERATIONS);
      System.out.println("NUM_UPDATE_STEPS=" + NUM_UPDATE_STEPS);
      System.out.println("NUM_HOLES=" + ImageRepair.NUM_HOLES);
      System.out.println("MAX_HOLE_SIZE=" + ImageRepair.MAX_HOLE_SIZE);

      // Random numbers.
      randomizer = new Random(Parameters.RANDOM_SEED);

      // Create fitness target.
      fitnessTarget = new ImageRepair(new String[0], 0);
      fitnessTarget.loadImage(ImageRepair.TARGET_IMAGE_FILE_NAME);

      // Create ImageRepair population.
      population = new ArrayList<ImageRepairMember>();
      for (int i = 0; i < POPULATION_SIZE; i++)
      {
         ImageRepairMember member = new ImageRepairMember();
         population.add(member);
         member.fitness = 0.0f;

         // Generate member parameters.
         member.NEIGHBORHOOD_DIMENSION = randomizer.nextInt(MAX_NEIGHBORHOOD_DIMENSION - MIN_NEIGHBORHOOD_DIMENSION + 1) + MIN_NEIGHBORHOOD_DIMENSION;
         if ((member.NEIGHBORHOOD_DIMENSION % 2) != 1)
         {
            if (randomizer.nextBoolean())
            {
               member.NEIGHBORHOOD_DIMENSION--;
            }
            else
            {
               member.NEIGHBORHOOD_DIMENSION++;
            }
         }
         member.NUM_NEIGHBORHOODS = randomizer.nextInt(MAX_NUM_NEIGHBORHOODS - MIN_NUM_NEIGHBORHOODS + 1) + MIN_NUM_NEIGHBORHOODS;
         member.NESTED_NEIGHBORHOOD_IMPORTANCE_WEIGHTS = new float[member.NUM_NEIGHBORHOODS];
         float f = 0.0f;
         for (int j = 0; j < member.NESTED_NEIGHBORHOOD_IMPORTANCE_WEIGHTS.length; j++)
         {
            member.NESTED_NEIGHBORHOOD_IMPORTANCE_WEIGHTS[j] = randomizer.nextFloat();
            f += member.NESTED_NEIGHBORHOOD_IMPORTANCE_WEIGHTS[j];
         }
         for (int j = 0; j < member.NESTED_NEIGHBORHOOD_IMPORTANCE_WEIGHTS.length; j++)
         {
            if (f > 0.0f)
            {
               member.NESTED_NEIGHBORHOOD_IMPORTANCE_WEIGHTS[j] /= f;
            }
            else
            {
               member.NESTED_NEIGHBORHOOD_IMPORTANCE_WEIGHTS[j] = 1.0f / member.NESTED_NEIGHBORHOOD_IMPORTANCE_WEIGHTS.length;
            }
         }
         member.METAMORPH_DIMENSION = randomizer.nextInt(MAX_METAMORPH_DIMENSION - MIN_METAMORPH_DIMENSION + 1) + MIN_METAMORPH_DIMENSION;
         if ((member.METAMORPH_DIMENSION % 2) != 1)
         {
            if (randomizer.nextBoolean())
            {
               member.METAMORPH_DIMENSION--;
            }
            else
            {
               member.METAMORPH_DIMENSION++;
            }
         }
         member.MAX_CELL_METAMORPHS   = randomizer.nextInt(MAX_MAX_CELL_METAMORPHS - MIN_MAX_CELL_METAMORPHS + 1) + MIN_MAX_CELL_METAMORPHS;
         member.METAMORPH_RANDOM_BIAS = (randomizer.nextFloat() * (MAX_METAMORPH_RANDOM_BIAS - MIN_METAMORPH_RANDOM_BIAS)) + MIN_METAMORPH_RANDOM_BIAS;
         switch (INHIBIT_COMPETING_MORPHOGENS)
         {
         case TRUE:
            member.INHIBIT_COMPETING_MORPHOGENS = true;
            break;

         case FALSE:
            member.INHIBIT_COMPETING_MORPHOGENS = false;
            break;

         case RANDOM:
            member.INHIBIT_COMPETING_MORPHOGENS = randomizer.nextBoolean();
            break;
         }
      }
   }


   // Generate member using crossover.
   ImageRepairMember crossover(ImageRepairMember parent1, ImageRepairMember parent2)
   {
      ImageRepairMember member = new ImageRepairMember();
      ImageRepairMember parent = null;

      if (randomizer.nextBoolean())
      {
         parent = parent1;
      }
      else
      {
         parent = parent2;
      }
      member.NEIGHBORHOOD_DIMENSION = parent.NEIGHBORHOOD_DIMENSION;
      if (randomizer.nextBoolean())
      {
         parent = parent1;
      }
      else
      {
         parent = parent2;
      }
      member.NUM_NEIGHBORHOODS = parent.NUM_NEIGHBORHOODS;
      member.NESTED_NEIGHBORHOOD_IMPORTANCE_WEIGHTS = new float[member.NUM_NEIGHBORHOODS];
      for (int i = 0; i < member.NESTED_NEIGHBORHOOD_IMPORTANCE_WEIGHTS.length; i++)
      {
         member.NESTED_NEIGHBORHOOD_IMPORTANCE_WEIGHTS[i] = parent.NESTED_NEIGHBORHOOD_IMPORTANCE_WEIGHTS[i];
      }
      if (randomizer.nextBoolean())
      {
         parent = parent1;
      }
      else
      {
         parent = parent2;
      }
      member.METAMORPH_DIMENSION = parent.METAMORPH_DIMENSION;
      if (randomizer.nextBoolean())
      {
         parent = parent1;
      }
      else
      {
         parent = parent2;
      }
      member.MAX_CELL_METAMORPHS = parent.MAX_CELL_METAMORPHS;
      if (randomizer.nextBoolean())
      {
         parent = parent1;
      }
      else
      {
         parent = parent2;
      }
      member.METAMORPH_RANDOM_BIAS = parent.METAMORPH_RANDOM_BIAS;
      if (randomizer.nextBoolean())
      {
         parent = parent1;
      }
      else
      {
         parent = parent2;
      }
      member.INHIBIT_COMPETING_MORPHOGENS = parent.INHIBIT_COMPETING_MORPHOGENS;
      return(member);
   }


   // Run optimization.
   public void run() throws Exception
   {
      // Evaluate initial population
      for (int i = 0; i < POPULATION_SIZE; i++)
      {
         ImageRepairMember member = population.get(i);
         member.evaluate(fitnessTarget);
      }
      sortPopulation();
      System.out.println("Generation=0");
      System.out.println("Member\tFitness");
      for (int i = 0; i < POPULATION_SIZE; i++)
      {
         ImageRepairMember member = population.get(i);
         System.out.println(i + "\t" + member.fitness);
      }

      // Run generations.
      for (int g = 0; g < NUM_GENERATIONS; g++)
      {
         // Select fit population.
         ArrayList<ImageRepairMember> fitPopulation = new ArrayList<ImageRepairMember>();
         for (int i = 0; i < FIT_POPULATION_SIZE; i++)
         {
            ImageRepairMember member = population.get(i);
            fitPopulation.add(member);
         }
         population = fitPopulation;

         // Replenish population.
         for (int i = 0, j = (POPULATION_SIZE - FIT_POPULATION_SIZE); i < j; i++)
         {
            ImageRepairMember member = null;
            if ((randomizer.nextFloat() <= CROSSOVER_PROBABILITY) && (FIT_POPULATION_SIZE > 0))
            {
               member = crossover(
                  population.get(randomizer.nextInt(FIT_POPULATION_SIZE)),
                  population.get(randomizer.nextInt(FIT_POPULATION_SIZE)));
            }
            else
            {
               member = new ImageRepairMember();
            }
            member.evaluate(fitnessTarget);
            population.add(member);
         }
         sortPopulation();

         System.out.println("Generation=" + (g + 1));
         System.out.println("Member\tFitness");
         for (int i = 0; i < POPULATION_SIZE; i++)
         {
            ImageRepairMember member = population.get(i);
            System.out.println(i + "\t" + member.fitness);
         }
      }

      // Print fittest parameters.
      if (FIT_POPULATION_SIZE > 0)
      {
         System.out.println("Fittest parameters:");
         ImageRepairMember member = population.get(0);
         member.setParameters();
         Parameters.print();
      }
   }


   // Sort population by descending fitness.
   void sortPopulation()
   {
      ArrayList<ImageRepairMember> sortedPopulation = new ArrayList<ImageRepairMember>();
      boolean done = false;
      while (!done)
      {
         done = true;
         ImageRepairMember fitMember      = null;
         int               fitMemberIndex = -1;
         for (int i = 0; i < POPULATION_SIZE; i++)
         {
            ImageRepairMember member = population.get(i);
            if (member != null)
            {
               if ((fitMember == null) || (member.fitness > fitMember.fitness))
               {
                  fitMember      = member;
                  fitMemberIndex = i;
               }
            }
         }
         if (fitMemberIndex != -1)
         {
            sortedPopulation.add(fitMember);
            population.set(fitMemberIndex, null);
            done = false;
         }
      }
      population = sortedPopulation;
   }


   // Main.
   public static void main(String[] args)
   {
      String usage = "Usage: java morphozoic.applications.ImageRepairOptimizer" + OPTIONS;

      // Get arguments.
      for (int i = 0; i < args.length; i++)
      {
         if (args[i].equals("-organismDimensions"))
         {
            i++;
            if (i == args.length)
            {
               System.err.println(usage);
               return;
            }
            int w = Integer.parseInt(args[i]);
            if (w <= 0)
            {
               System.err.println("Organism width dimension must be positive");
               System.err.println(usage);
               return;
            }
            i++;
            if (i == args.length)
            {
               System.err.println(usage);
               return;
            }
            int h = Integer.parseInt(args[i]);
            if (h <= 0)
            {
               System.err.println("Organism height dimension must be positive");
               System.err.println(usage);
               return;
            }
            Parameters.ORGANISM_DIMENSIONS = new Dimension(w, h);
         }
         else if (args[i].equals("-numCellTypes"))
         {
            i++;
            if (i == args.length)
            {
               System.err.println(usage);
               return;
            }
            Parameters.NUM_CELL_TYPES = Integer.parseInt(args[i]);
            if (Parameters.NUM_CELL_TYPES <= 0)
            {
               System.err.println("Number of cell types must be positive");
               System.err.println(usage);
               return;
            }
         }
         else if (args[i].equals("-randomSeed"))
         {
            i++;
            if (i == args.length)
            {
               System.err.println(usage);
               return;
            }
            Parameters.RANDOM_SEED = Integer.parseInt(args[i]);
         }
         else if (args[i].equals("-populationSize"))
         {
            i++;
            if (i == args.length)
            {
               System.err.println(usage);
               return;
            }
            POPULATION_SIZE = Integer.parseInt(args[i]);
            if (POPULATION_SIZE <= 0)
            {
               System.err.println("Population size must be positive");
               System.err.println(usage);
               return;
            }
         }
         else if (args[i].equals("-fitPopulationSize"))
         {
            i++;
            if (i == args.length)
            {
               System.err.println(usage);
               return;
            }
            FIT_POPULATION_SIZE = Integer.parseInt(args[i]);
            if (FIT_POPULATION_SIZE < 0)
            {
               System.err.println("Invalid fit population size");
               System.err.println(usage);
               return;
            }
         }
         else if (args[i].equals("-crossoverProbability"))
         {
            i++;
            if (i == args.length)
            {
               System.err.println(usage);
               return;
            }
            CROSSOVER_PROBABILITY = Float.parseFloat(args[i]);
            if ((CROSSOVER_PROBABILITY < 0.0f) || (CROSSOVER_PROBABILITY > 1.0f))
            {
               System.err.println("Invalid crossover probability");
               System.err.println(usage);
               return;
            }
         }
         else if (args[i].equals("-numGenerations"))
         {
            i++;
            if (i == args.length)
            {
               System.err.println(usage);
               return;
            }
            NUM_GENERATIONS = Integer.parseInt(args[i]);
            if (NUM_GENERATIONS < 0)
            {
               System.err.println("Invalid number of generations");
               System.err.println(usage);
               return;
            }
         }
         else if (args[i].equals("-numUpdateSteps"))
         {
            i++;
            if (i == args.length)
            {
               System.err.println(usage);
               return;
            }
            NUM_UPDATE_STEPS = Integer.parseInt(args[i]);
            if (NUM_UPDATE_STEPS < 0)
            {
               System.err.println("Invalid number of update steps");
               System.err.println(usage);
               return;
            }
         }
         else if (args[i].equals("-minNeighborhoodDimension"))
         {
            i++;
            if (i == args.length)
            {
               System.err.println(usage);
               return;
            }
            MIN_NEIGHBORHOOD_DIMENSION = Integer.parseInt(args[i]);
            if (MIN_NEIGHBORHOOD_DIMENSION <= 0)
            {
               System.err.println("Invalid minimum neighborhood dimension");
               System.err.println(usage);
               return;
            }
            if ((MIN_NEIGHBORHOOD_DIMENSION % 2) != 1)
            {
               System.err.println("Invalid minimum neighborhood dimension");
               System.err.println(usage);
               return;
            }
         }
         else if (args[i].equals("-maxNeighborhoodDimension"))
         {
            i++;
            if (i == args.length)
            {
               System.err.println(usage);
               return;
            }
            MAX_NEIGHBORHOOD_DIMENSION = Integer.parseInt(args[i]);
            if (MAX_NEIGHBORHOOD_DIMENSION <= 0)
            {
               System.err.println("Invalid maximum neighborhood dimension");
               System.err.println(usage);
               return;
            }
            if ((MAX_NEIGHBORHOOD_DIMENSION % 2) != 1)
            {
               System.err.println("Invalid maximum neighborhood dimension");
               System.err.println(usage);
               return;
            }
         }
         else if (args[i].equals("-minNumNeighborhoods"))
         {
            i++;
            if (i == args.length)
            {
               System.err.println(usage);
               return;
            }
            MIN_NUM_NEIGHBORHOODS = Integer.parseInt(args[i]);
            if (MIN_NUM_NEIGHBORHOODS <= 0)
            {
               System.err.println("Invalid minimum number of neighborhoods");
               System.err.println(usage);
               return;
            }
         }
         else if (args[i].equals("-maxNumNeighborhoods"))
         {
            i++;
            if (i == args.length)
            {
               System.err.println(usage);
               return;
            }
            MAX_NUM_NEIGHBORHOODS = Integer.parseInt(args[i]);
            if (MAX_NUM_NEIGHBORHOODS <= 0)
            {
               System.err.println("Invalid maximum number of neighborhoods");
               System.err.println(usage);
               return;
            }
         }
         else if (args[i].equals("-minMetamorphDimension"))
         {
            i++;
            if (i == args.length)
            {
               System.err.println(usage);
               return;
            }
            MIN_METAMORPH_DIMENSION = Integer.parseInt(args[i]);
            if (MIN_METAMORPH_DIMENSION <= 0)
            {
               System.err.println("Invalid minimum metamorph dimension");
               System.err.println(usage);
               return;
            }
            if ((MIN_METAMORPH_DIMENSION % 2) != 1)
            {
               System.err.println("Invalid minimum metamorph dimension");
               System.err.println(usage);
               return;
            }
         }
         else if (args[i].equals("-maxMetamorphDimension"))
         {
            i++;
            if (i == args.length)
            {
               System.err.println(usage);
               return;
            }
            MAX_METAMORPH_DIMENSION = Integer.parseInt(args[i]);
            if (MAX_METAMORPH_DIMENSION <= 0)
            {
               System.err.println("Invalid maximum metamorph dimension");
               System.err.println(usage);
               return;
            }
            if ((MAX_METAMORPH_DIMENSION % 2) != 1)
            {
               System.err.println("Invalid maximum metamorph dimension");
               System.err.println(usage);
               return;
            }
         }
         else if (args[i].equals("-minMaxCellMetamorphs"))
         {
            i++;
            if (i == args.length)
            {
               System.err.println(usage);
               return;
            }
            MIN_MAX_CELL_METAMORPHS = Integer.parseInt(args[i]);
            if (MIN_MAX_CELL_METAMORPHS <= 0)
            {
               System.err.println("Invalid minimum maximum number of cell metamorphs");
               System.err.println(usage);
               return;
            }
         }
         else if (args[i].equals("-maxMaxCellMetamorphs"))
         {
            i++;
            if (i == args.length)
            {
               System.err.println(usage);
               return;
            }
            MAX_MAX_CELL_METAMORPHS = Integer.parseInt(args[i]);
            if (MAX_MAX_CELL_METAMORPHS <= 0)
            {
               System.err.println("Invalid maximum maximum number of cell metamorphs");
               System.err.println(usage);
               return;
            }
         }
         else if (args[i].equals("-minMetamorphRandomBias"))
         {
            i++;
            if (i == args.length)
            {
               System.err.println(usage);
               return;
            }
            MIN_METAMORPH_RANDOM_BIAS = Float.parseFloat(args[i]);
            if ((MIN_METAMORPH_RANDOM_BIAS < 0.0f) || (MIN_METAMORPH_RANDOM_BIAS > 1.0f))
            {
               System.err.println("Invalid minimum metamorph random bias");
               System.err.println(usage);
               return;
            }
         }
         else if (args[i].equals("-maxMetamorphRandomBias"))
         {
            i++;
            if (i == args.length)
            {
               System.err.println(usage);
               return;
            }
            MAX_METAMORPH_RANDOM_BIAS = Float.parseFloat(args[i]);
            if ((MAX_METAMORPH_RANDOM_BIAS < 0.0f) || (MAX_METAMORPH_RANDOM_BIAS > 1.0f))
            {
               System.err.println("Invalid maximum metamorph random bias");
               System.err.println(usage);
               return;
            }
         }
         else if (args[i].equals("-deltaMetamorphRandomBias"))
         {
            i++;
            if (i == args.length)
            {
               System.err.println(usage);
               return;
            }
            DELTA_METAMORPH_RANDOM_BIAS = Float.parseFloat(args[i]);
            if ((DELTA_METAMORPH_RANDOM_BIAS < 0.0f) || (DELTA_METAMORPH_RANDOM_BIAS > 1.0f))
            {
               System.err.println("Invalid delta metamorph random bias");
               System.err.println(usage);
               return;
            }
         }
         else if (args[i].equals("-inhibitCompetingMorphogens"))
         {
            i++;
            if (i == args.length)
            {
               System.err.println(usage);
               return;
            }
            if (args[i].equals("true"))
            {
               INHIBIT_COMPETING_MORPHOGENS = INHIBIT_COMPETING_MORPHOGENS_VALUES.TRUE;
            }
            else if (args[i].equals("false"))
            {
               INHIBIT_COMPETING_MORPHOGENS = INHIBIT_COMPETING_MORPHOGENS_VALUES.FALSE;
            }
            else if (args[i].equals("random"))
            {
               INHIBIT_COMPETING_MORPHOGENS = INHIBIT_COMPETING_MORPHOGENS_VALUES.RANDOM;
            }
            else
            {
               System.err.println("Invalid inhibit competing morphogens value");
               System.err.println(usage);
               return;
            }
         }
         else if (args[i].equals("-imageFilename"))
         {
            i++;
            if (i == args.length)
            {
               System.err.println(usage);
               return;
            }
            ImageRepair.TARGET_IMAGE_FILE_NAME = args[i];
         }
         else if (args[i].equals("-numHoles"))
         {
            i++;
            if (i == args.length)
            {
               System.err.println(usage);
               return;
            }
            ImageRepair.NUM_HOLES = Integer.parseInt(args[i]);
            if (ImageRepair.NUM_HOLES < 0)
            {
               System.err.println("Invalid number of holes");
               return;
            }
         }
         else if (args[i].equals("-maxHoleSize"))
         {
            i++;
            if (i == args.length)
            {
               System.err.println(usage);
               return;
            }
            ImageRepair.MAX_HOLE_SIZE = Integer.parseInt(args[i]);
            if (ImageRepair.MAX_HOLE_SIZE < 1)
            {
               System.err.println("Maximum hole size must be positive");
               return;
            }
         }
         else
         {
            System.out.println(usage);
            return;
         }
      }
      if (FIT_POPULATION_SIZE > POPULATION_SIZE)
      {
         System.err.println("Fit population size cannot exceed population size");
         return;
      }
      if (MIN_NEIGHBORHOOD_DIMENSION > MAX_NEIGHBORHOOD_DIMENSION)
      {
         System.err.println("Minimum neighborhood dimension cannot exceed maximum neighborhood dimension");
         System.err.println(usage);
         return;
      }
      if (MIN_NUM_NEIGHBORHOODS > MAX_NUM_NEIGHBORHOODS)
      {
         System.err.println("Minimum number of neighborhoods cannot exceed maximum number of neighborhoods");
         System.err.println(usage);
         return;
      }
      if (MIN_METAMORPH_DIMENSION > MAX_METAMORPH_DIMENSION)
      {
         System.err.println("Minimum metamorph dimension cannot exceed maximum metamorph dimension");
         System.err.println(usage);
         return;
      }
      if (MIN_MAX_CELL_METAMORPHS > MAX_MAX_CELL_METAMORPHS)
      {
         System.err.println("Minimum maximum cell metamorphs cannot exceed maximum maximum cell metamorphs");
         System.err.println(usage);
         return;
      }
      if (MIN_METAMORPH_RANDOM_BIAS > MAX_METAMORPH_RANDOM_BIAS)
      {
         System.err.println("Minimum metamorph random bias cannot exceed maximum metamorph random bias");
         System.err.println(usage);
         return;
      }

      try
      {
         ImageRepairOptimizer optimizer = new ImageRepairOptimizer();
         optimizer.run();
      }
      catch (Exception e) {
         System.err.println(e.getMessage());
      }
   }
}
